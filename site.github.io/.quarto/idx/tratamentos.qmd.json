{"title":"tratamentos","markdown":{"yaml":{"title":"tratamentos","editor":"visual"},"headingText":"Repelência - por tratamento","containsRefs":false,"markdown":"\n\n\n## Baixando e organizando os dados\n\n```{r, echo=FALSE, results='hide', warning=FALSE, message=FALSE}\narenas <- read.csv(\"arenas_fip606.csv\", header = T, stringsAsFactors = T)\n\n# Analisar as variáveis do modelo\nif(!require(dplyr)) install.packages(\"dplyr\") \nlibrary(dplyr)\n\nglimpse(arenas)\n\n# Ajustar variáveis no dataframe para facilitar análises futuras\narenas$local <- as.character(arenas$local)\n\narenas$local <- ifelse(arenas$local == -1, \"neg_1\", arenas$local)\narenas$local <- ifelse(arenas$local == \"-0,5\", \"neg_05\", arenas$local)\n```\n\n```{r, echo=FALSE, results='hide', warning=FALSE, message=FALSE}\n# Criando novos dataframes por tratamento\n\ndatant <- arenas %>% \n  filter(trat == \"NT\")\n\ndatae <- arenas %>% \n  filter(trat == \"E\")\n\ndatag <- arenas %>% \n  filter(trat == \"G\")\n\ndatac <- arenas %>% \n  filter(trat == \"C\")\n\ndatat <- arenas %>% \n  filter(trat == \"T\")\n```\n\n*Os dados foram separados para fazermos as análises por tratamento.*\n\n## Gerando modelos\n\n```{r, echo=FALSE, eval=TRUE}\n\nmodnt <- kruskal.test(num ~ local, data = datant)\nprint(modnt)\n\nmode <- kruskal.test(num ~ local, data = datae)\nprint(mode)\n\nmodg <- kruskal.test(num ~ local, data = datag)\nprint(modg)\n\nmodc <- kruskal.test(num ~ local, data = datac)\nprint(modc)\n\nmodt <- kruskal.test(num ~ local, data = datat)\nprint(modt)\n\n```\n\n*Todos os modelos apresentam diferenças significativas e se adequam aos dados.*\n\n*Modelos foram testados com kruskal-wallis pois haviamos a informação de que as variáveis não seguem os pressupostos de normalidade e homocedasticidade.*\n\n## Análise de pressupostos\n\n### Normalidade\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(nortest)) install.packages(\"nortest\")\nlibrary(nortest)\n\ndatant %>%\n  group_by(trat) %>%\n  summarise(\n    Estatística_Shapiro = shapiro.test(num)$statistic,\n    p_valor = shapiro.test(num)$p.value\n  )\n\ndatae %>%\n  group_by(trat) %>%\n  summarise(\n    Estatística_Shapiro = shapiro.test(num)$statistic,\n    p_valor = shapiro.test(num)$p.value\n  )\n\ndatag %>%\n  group_by(trat) %>%\n  summarise(\n    Estatística_Shapiro = shapiro.test(num)$statistic,\n    p_valor = shapiro.test(num)$p.value\n  )\n\ndatac %>%\n  group_by(trat) %>%\n  summarise(\n    Estatística_Shapiro = shapiro.test(num)$statistic,\n    p_valor = shapiro.test(num)$p.value\n  )\n\ndatat %>%\n  group_by(trat) %>%\n  summarise(\n    Estatística_Shapiro = shapiro.test(num)$statistic,\n    p_valor = shapiro.test(num)$p.value\n  )\n\n```\n\n*Confrimamos que os dados de interesse não seguem o pressuposto de normalidade.*\n\n### Homocedasticidade\n\n```{r, echo=FALSE, eval=TRUE}\nbartlett.test(num ~ local, data = datant)\n\nbartlett.test(num ~ local, data = datae)\n\nbartlett.test(num ~ local, data = datag)\n\nbartlett.test(num ~ local, data = datac)\n\nbartlett.test(num ~ local, data = datat)\n\n```\n\n*Confrimamos que os dados de interesse não seguem o pressuposto de homocedasticidade.*\n\n## Testes post hoc\n\n### Dados do tratamento NT (Controle)\n\n#### Teste post-hoc\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(rstatix)) install.packages(\"rstatix\")\nlibrary(rstatix) \n\ndunn_nt <- dunn_test(num ~ local, data = datant, p.adjust.method = \"bonferroni\")\n```\n\n*Teste de Dunn é o post-hoc utilizado para modelos de Kruskal-Wallis.*\n\n#### Organizando as letras e ordem dos resultados do tratamento NT\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(multcompView)) install.packages(\"multcompView\")\nlibrary(multcompView)\n\n# Criar matriz de comparações para o multcompView\np_nt <- setNames(dunn_nt$p.adj, \n                    paste(dunn_nt$group1, dunn_nt$group2, sep = \"-\"))\n\n# Obter letras de significância\nletter_nt <- multcompLetters(p_nt)\n\n# Preparar dados para o gráfico\nletras_plot_nt <- data.frame(\n  local = names(letter_nt$Letters),\n  letra = letter_nt$Letters,\n  y_pos = max(datant$num) * 1.1)\n\n\n\n# Definir a ordem desejada das variáveis no eixo x\n\nordem_desejada <- c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\")\n\n# Converter a variável 'local' em fator com a ordem correta\ndatant <- datant %>%\n  mutate(local = factor(local, \n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = ordem_desejada))\n\n# Atualizar também o dataframe letras_plot\nif(exists(\"letras_plot_nt\")) {\n  letras_plot_nt <- letras_plot_nt %>%\n    mutate(local = factor(local, \n                         levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                         labels = ordem_desejada))\n  }\n\n\n# Modificar os níveis do fator nos dados\ndatant <- datant %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n# Atualizar o dataframe letras_plot\nletras_plot_nt <- letras_plot_nt %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n```\n\n#### Gráfico do tratamento NT\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nggplot(datant, aes(x = local, y = num)) +\n  geom_boxplot(aes(fill = local), width = 0.6, show.legend = FALSE) +\n  geom_text(data = letras_plot_nt, \n            aes(x = local, y = y_pos, label = letra),\n            size = 6, vjust = 0) +\n  labs(\n    title = \"Distribuição por Local\",\n    subtitle = paste(\"Teste Kruskal-Wallis, p =\", format.pval(mode$p.value, digits = 3)),\n    x = \"Local\",\n    y = \"Número de Insetos\"\n  ) +\n  theme_minimal(base_size = 14) +\n  scale_y_continuous(expand = expansion(mult = c(0.05, 0.2))) +\n  scale_fill_viridis_d(option = \"D\", begin = 0.2, end = 0.8)\n```\n\n*Os processos acima serão repetidos da mesma forma, para todos os tratamentos.*\n\n### Dados do tratamento E\n\n#### Teste post-hoc\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(rstatix)) install.packages(\"rstatix\")\nlibrary(rstatix) \n\n# Teste de Dunn é o post-hoc utilizado para modelos de Kruskal-Wallis\ndunn_e <- dunn_test(num ~ local, data = datae, p.adjust.method = \"bonferroni\")\n```\n\n#### Organizando as letras e ordem dos resultados do tratamento E\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(multcompView)) install.packages(\"multcompView\")\nlibrary(multcompView)\nif(!require(dplyr)) install.packages(\"dplyr\")\nlibrary(dplyr)\n\n# Criar matriz de comparações para o multcompView\np_values <- setNames(dunn_e$p.adj, \n                    paste(dunn_e$group1, dunn_e$group2, sep = \"-\"))\n\n# Obter letras de significância\nletter_info <- multcompLetters(p_values)\n\n# Preparar dados para o gráfico\nletras_plot_e <- data.frame(\n  local = names(letter_info$Letters),\n  letra = letter_info$Letters,\n  y_pos = max(datae$num) * 1.1\n)\n\n# Definir a ordem desejada das variáveis no eixo x\nordem_desejada <- c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\")  # Padronizando para ponto decimal\n\n# Converter a variável 'local' em fator com a ordem correta\ndatae <- datae %>%\n  mutate(local = factor(\n    local, \n    levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n    labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")\n  ))\n\n# Atualizar também o dataframe letras_plot\nif(exists(\"letras_plot_e\")) {\n  letras_plot_e <- letras_plot_e %>%\n    mutate(local = factor(\n      local, \n      levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n      labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")\n    ))\n}\n```\n\n#### Gráfico do tratamento E\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nggplot(datae, aes(x = local, y = num)) +\n  geom_boxplot(aes(fill = local), width = 0.6, show.legend = FALSE) +\n  geom_text(data = letras_plot_e, \n            aes(x = local, y = y_pos, label = letra),\n            size = 6, vjust = 0) +\n  labs(\n    title = \"Distribuição por Local\",\n    subtitle = paste(\"Teste Kruskal-Wallis, p =\", format.pval(mode$p.value, digits = 3)),\n    x = \"Local\",\n    y = \"Número de Insetos\"\n  ) +\n  theme_minimal(base_size = 14) +\n  scale_y_continuous(expand = expansion(mult = c(0.05, 0.2))) +\n  scale_fill_viridis_d(option = \"D\", begin = 0.2, end = 0.8)\n```\n\n### Dados do tratamento G\n\n#### Teste post-hoc\n\n```{r}\nif(!require(rstatix)) install.packages(\"rstatix\")\nlibrary(rstatix) \n\n# Teste de Dunn é o post-hoc utilizado para modelos de Kruskal-Wallis\ndunn_g <- dunn_test(num ~ local, data = datag, p.adjust.method = \"bonferroni\")\n```\n\n#### Organizando as letras e ordem dos resultados do tratamento G\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(multcompView)) install.packages(\"multcompView\")\nlibrary(multcompView)\n\n# Criar matriz de comparações para o multcompView\np_g <- setNames(dunn_nt$p.adj, \n                    paste(dunn_g$group1, dunn_g$group2, sep = \"-\"))\n\n# Obter letras de significância\nletter_g <- multcompLetters(p_g)\n\n# Preparar dados para o gráfico\nletras_plot_g <- data.frame(\n  local = names(letter_g$Letters),\n  letra = letter_g$Letters,\n  y_pos = max(datag$num) * 1.1)\n\n\n\n# Definir a ordem desejada das variáveis no eixo x\n\nordem_desejada <- c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\")\n\n# Converter a variável 'local' em fator com a ordem correta\ndatag <- datag %>%\n  mutate(local = factor(local, \n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = ordem_desejada))\n\n# Atualizar também o dataframe letras_plot\nif(exists(\"letras_plot_g\")) {\n  letras_plot_g <- letras_plot_g %>%\n    mutate(local = factor(local, \n                         levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                         labels = ordem_desejada))\n  }\n\n\n# Modificar os níveis do fator nos dados\ndatag <- datag %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n# Atualizar o dataframe letras_plot\nletras_plot_g <- letras_plot_g %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n```\n\n#### Gráfico do tratamento G\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nggplot(datag, aes(x = local, y = num)) +\n  geom_boxplot(aes(fill = local), width = 0.6, show.legend = FALSE) +\n  geom_text(data = letras_plot_g, \n            aes(x = local, y = y_pos, label = letra),\n            size = 6, vjust = 0) +\n  labs(\n    title = \"Distribuição por Local\",\n    subtitle = paste(\"Teste Kruskal-Wallis, p =\", format.pval(mode$p.value, digits = 3)),\n    x = \"Local\",\n    y = \"Número de Insetos\"\n  ) +\n  theme_minimal(base_size = 14) +\n  scale_y_continuous(expand = expansion(mult = c(0.05, 0.2))) +\n  scale_fill_viridis_d(option = \"D\", begin = 0.2, end = 0.8)\n```\n\n### Dados do tratamento C\n\n#### Teste post-hoc\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(rstatix)) install.packages(\"rstatix\")\nlibrary(rstatix) \n\n# Teste de Dunn é o post-hoc utilizado para modelos de Kruskal-Wallis\ndunn_c <- dunn_test(num ~ local, data = datac, p.adjust.method = \"bonferroni\")\n```\n\n#### Organizando as letras e ordem dos resultados do tratamento C\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(multcompView)) install.packages(\"multcompView\")\nlibrary(multcompView)\n\n# Criar matriz de comparações para o multcompView\np_c <- setNames(dunn_c$p.adj, \n                    paste(dunn_c$group1, dunn_c$group2, sep = \"-\"))\n\n# Obter letras de significância\nletter_c <- multcompLetters(p_c)\n\n# Preparar dados para o gráfico\nletras_plot_c <- data.frame(\n  local = names(letter_c$Letters),\n  letra = letter_c$Letters,\n  y_pos = max(datac$num) * 1.1)\n\n\n\n# Definir a ordem desejada das variáveis no eixo x\n\nordem_desejada <- c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\")\n\n# Converter a variável 'local' em fator com a ordem correta\ndatac <- datac %>%\n  mutate(local = factor(local, \n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = ordem_desejada))\n\n# Atualizar também o dataframe letras_plot\nif(exists(\"letras_plot_c\")) {\n  letras_plot_c <- letras_plot_c %>%\n    mutate(local = factor(local, \n                         levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                         labels = ordem_desejada))\n  }\n\n\n# Modificar os níveis do fator nos dados\ndatac <- datac %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n# Atualizar o dataframe letras_plot\nletras_plot_c <- letras_plot_c %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n```\n\n#### Gráfico do tratamento C\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nggplot(datac, aes(x = local, y = num)) +\n  geom_boxplot(aes(fill = local), width = 0.6, show.legend = FALSE) +\n  geom_text(data = letras_plot_c, \n            aes(x = local, y = y_pos, label = letra),\n            size = 6, vjust = 0) +\n  labs(\n    title = \"Distribuição por Local\",\n    subtitle = paste(\"Teste Kruskal-Wallis, p =\", format.pval(mode$p.value, digits = 3)),\n    x = \"Local\",\n    y = \"Número de Insetos\"\n  ) +\n  theme_minimal(base_size = 14) +\n  scale_y_continuous(expand = expansion(mult = c(0.05, 0.2))) +\n  scale_fill_viridis_d(option = \"D\", begin = 0.2, end = 0.8)\n```\n\n### Dados do tratamento T\n\n#### Teste post-hoc\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(rstatix)) install.packages(\"rstatix\")\nlibrary(rstatix) \n\n# Teste de Dunn é o post-hoc utilizado para modelos de Kruskal-Wallis\ndunn_t <- dunn_test(num ~ local, data = datat, p.adjust.method = \"bonferroni\")\n```\n\n#### Organizando as letras e ordem dos resultados do tratamento T\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(multcompView)) install.packages(\"multcompView\")\nlibrary(multcompView)\n\n# Criar matriz de comparações para o multcompView\np_t <- setNames(dunn_t$p.adj, \n                    paste(dunn_t$group1, dunn_t$group2, sep = \"-\"))\n\n# Obter letras de significância\nletter_t <- multcompLetters(p_t)\n\n# Preparar dados para o gráfico\nletras_plot_t <- data.frame(\n  local = names(letter_t$Letters),\n  letra = letter_t$Letters,\n  y_pos = max(datat$num) * 1.1)\n\n\n\n# Definir a ordem desejada das variáveis no eixo x\n\nordem_desejada <- c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\")\n\n# Converter a variável 'local' em fator com a ordem correta\ndatat <- datat %>%\n  mutate(local = factor(local, \n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = ordem_desejada))\n\n# Atualizar também o dataframe letras_plot\nif(exists(\"letras_plot_c\")) {\n  letras_plot_t <- letras_plot_t %>%\n    mutate(local = factor(local, \n                         levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                         labels = ordem_desejada))\n  }\n\n\n# Modificar os níveis do fator nos dados\ndatat <- datat %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n# Atualizar o dataframe letras_plot\nletras_plot_t <- letras_plot_t %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n\n```\n\n#### Gráfico do tratamento T\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nggplot(datat, aes(x = local, y = num)) +\n  geom_boxplot(aes(fill = local), width = 0.6, show.legend = FALSE) +\n  geom_text(data = letras_plot_t, \n            aes(x = local, y = y_pos, label = letra),\n            size = 6, vjust = 0) +\n  labs(\n    title = \"Distribuição por Local\",\n    subtitle = paste(\"Teste Kruskal-Wallis, p =\", format.pval(mode$p.value, digits = 3)),\n    x = \"Local\",\n    y = \"Número de Insetos\"\n  ) +\n  theme_minimal(base_size = 14) +\n  scale_y_continuous(expand = expansion(mult = c(0.05, 0.2))) +\n  scale_fill_viridis_d(option = \"D\", begin = 0.2, end = 0.8)\n```\n\n*Com isso, podemos concluir que em todos os tratamentos, os insetos preferem as extremidades do sistema fechado, onde o alimento é presente. Porém, não há diferenças significativas entre as câmaras com alimento contaminado com composto repelente e as câmaras sem a contaminação.*\n\n*Isso indica que o efeito de repelência dos compostos não é significativo.*\n","srcMarkdownNoYaml":"\n\n# Repelência - por tratamento\n\n## Baixando e organizando os dados\n\n```{r, echo=FALSE, results='hide', warning=FALSE, message=FALSE}\narenas <- read.csv(\"arenas_fip606.csv\", header = T, stringsAsFactors = T)\n\n# Analisar as variáveis do modelo\nif(!require(dplyr)) install.packages(\"dplyr\") \nlibrary(dplyr)\n\nglimpse(arenas)\n\n# Ajustar variáveis no dataframe para facilitar análises futuras\narenas$local <- as.character(arenas$local)\n\narenas$local <- ifelse(arenas$local == -1, \"neg_1\", arenas$local)\narenas$local <- ifelse(arenas$local == \"-0,5\", \"neg_05\", arenas$local)\n```\n\n```{r, echo=FALSE, results='hide', warning=FALSE, message=FALSE}\n# Criando novos dataframes por tratamento\n\ndatant <- arenas %>% \n  filter(trat == \"NT\")\n\ndatae <- arenas %>% \n  filter(trat == \"E\")\n\ndatag <- arenas %>% \n  filter(trat == \"G\")\n\ndatac <- arenas %>% \n  filter(trat == \"C\")\n\ndatat <- arenas %>% \n  filter(trat == \"T\")\n```\n\n*Os dados foram separados para fazermos as análises por tratamento.*\n\n## Gerando modelos\n\n```{r, echo=FALSE, eval=TRUE}\n\nmodnt <- kruskal.test(num ~ local, data = datant)\nprint(modnt)\n\nmode <- kruskal.test(num ~ local, data = datae)\nprint(mode)\n\nmodg <- kruskal.test(num ~ local, data = datag)\nprint(modg)\n\nmodc <- kruskal.test(num ~ local, data = datac)\nprint(modc)\n\nmodt <- kruskal.test(num ~ local, data = datat)\nprint(modt)\n\n```\n\n*Todos os modelos apresentam diferenças significativas e se adequam aos dados.*\n\n*Modelos foram testados com kruskal-wallis pois haviamos a informação de que as variáveis não seguem os pressupostos de normalidade e homocedasticidade.*\n\n## Análise de pressupostos\n\n### Normalidade\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(nortest)) install.packages(\"nortest\")\nlibrary(nortest)\n\ndatant %>%\n  group_by(trat) %>%\n  summarise(\n    Estatística_Shapiro = shapiro.test(num)$statistic,\n    p_valor = shapiro.test(num)$p.value\n  )\n\ndatae %>%\n  group_by(trat) %>%\n  summarise(\n    Estatística_Shapiro = shapiro.test(num)$statistic,\n    p_valor = shapiro.test(num)$p.value\n  )\n\ndatag %>%\n  group_by(trat) %>%\n  summarise(\n    Estatística_Shapiro = shapiro.test(num)$statistic,\n    p_valor = shapiro.test(num)$p.value\n  )\n\ndatac %>%\n  group_by(trat) %>%\n  summarise(\n    Estatística_Shapiro = shapiro.test(num)$statistic,\n    p_valor = shapiro.test(num)$p.value\n  )\n\ndatat %>%\n  group_by(trat) %>%\n  summarise(\n    Estatística_Shapiro = shapiro.test(num)$statistic,\n    p_valor = shapiro.test(num)$p.value\n  )\n\n```\n\n*Confrimamos que os dados de interesse não seguem o pressuposto de normalidade.*\n\n### Homocedasticidade\n\n```{r, echo=FALSE, eval=TRUE}\nbartlett.test(num ~ local, data = datant)\n\nbartlett.test(num ~ local, data = datae)\n\nbartlett.test(num ~ local, data = datag)\n\nbartlett.test(num ~ local, data = datac)\n\nbartlett.test(num ~ local, data = datat)\n\n```\n\n*Confrimamos que os dados de interesse não seguem o pressuposto de homocedasticidade.*\n\n## Testes post hoc\n\n### Dados do tratamento NT (Controle)\n\n#### Teste post-hoc\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(rstatix)) install.packages(\"rstatix\")\nlibrary(rstatix) \n\ndunn_nt <- dunn_test(num ~ local, data = datant, p.adjust.method = \"bonferroni\")\n```\n\n*Teste de Dunn é o post-hoc utilizado para modelos de Kruskal-Wallis.*\n\n#### Organizando as letras e ordem dos resultados do tratamento NT\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(multcompView)) install.packages(\"multcompView\")\nlibrary(multcompView)\n\n# Criar matriz de comparações para o multcompView\np_nt <- setNames(dunn_nt$p.adj, \n                    paste(dunn_nt$group1, dunn_nt$group2, sep = \"-\"))\n\n# Obter letras de significância\nletter_nt <- multcompLetters(p_nt)\n\n# Preparar dados para o gráfico\nletras_plot_nt <- data.frame(\n  local = names(letter_nt$Letters),\n  letra = letter_nt$Letters,\n  y_pos = max(datant$num) * 1.1)\n\n\n\n# Definir a ordem desejada das variáveis no eixo x\n\nordem_desejada <- c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\")\n\n# Converter a variável 'local' em fator com a ordem correta\ndatant <- datant %>%\n  mutate(local = factor(local, \n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = ordem_desejada))\n\n# Atualizar também o dataframe letras_plot\nif(exists(\"letras_plot_nt\")) {\n  letras_plot_nt <- letras_plot_nt %>%\n    mutate(local = factor(local, \n                         levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                         labels = ordem_desejada))\n  }\n\n\n# Modificar os níveis do fator nos dados\ndatant <- datant %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n# Atualizar o dataframe letras_plot\nletras_plot_nt <- letras_plot_nt %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n```\n\n#### Gráfico do tratamento NT\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nggplot(datant, aes(x = local, y = num)) +\n  geom_boxplot(aes(fill = local), width = 0.6, show.legend = FALSE) +\n  geom_text(data = letras_plot_nt, \n            aes(x = local, y = y_pos, label = letra),\n            size = 6, vjust = 0) +\n  labs(\n    title = \"Distribuição por Local\",\n    subtitle = paste(\"Teste Kruskal-Wallis, p =\", format.pval(mode$p.value, digits = 3)),\n    x = \"Local\",\n    y = \"Número de Insetos\"\n  ) +\n  theme_minimal(base_size = 14) +\n  scale_y_continuous(expand = expansion(mult = c(0.05, 0.2))) +\n  scale_fill_viridis_d(option = \"D\", begin = 0.2, end = 0.8)\n```\n\n*Os processos acima serão repetidos da mesma forma, para todos os tratamentos.*\n\n### Dados do tratamento E\n\n#### Teste post-hoc\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(rstatix)) install.packages(\"rstatix\")\nlibrary(rstatix) \n\n# Teste de Dunn é o post-hoc utilizado para modelos de Kruskal-Wallis\ndunn_e <- dunn_test(num ~ local, data = datae, p.adjust.method = \"bonferroni\")\n```\n\n#### Organizando as letras e ordem dos resultados do tratamento E\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(multcompView)) install.packages(\"multcompView\")\nlibrary(multcompView)\nif(!require(dplyr)) install.packages(\"dplyr\")\nlibrary(dplyr)\n\n# Criar matriz de comparações para o multcompView\np_values <- setNames(dunn_e$p.adj, \n                    paste(dunn_e$group1, dunn_e$group2, sep = \"-\"))\n\n# Obter letras de significância\nletter_info <- multcompLetters(p_values)\n\n# Preparar dados para o gráfico\nletras_plot_e <- data.frame(\n  local = names(letter_info$Letters),\n  letra = letter_info$Letters,\n  y_pos = max(datae$num) * 1.1\n)\n\n# Definir a ordem desejada das variáveis no eixo x\nordem_desejada <- c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\")  # Padronizando para ponto decimal\n\n# Converter a variável 'local' em fator com a ordem correta\ndatae <- datae %>%\n  mutate(local = factor(\n    local, \n    levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n    labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")\n  ))\n\n# Atualizar também o dataframe letras_plot\nif(exists(\"letras_plot_e\")) {\n  letras_plot_e <- letras_plot_e %>%\n    mutate(local = factor(\n      local, \n      levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n      labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")\n    ))\n}\n```\n\n#### Gráfico do tratamento E\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nggplot(datae, aes(x = local, y = num)) +\n  geom_boxplot(aes(fill = local), width = 0.6, show.legend = FALSE) +\n  geom_text(data = letras_plot_e, \n            aes(x = local, y = y_pos, label = letra),\n            size = 6, vjust = 0) +\n  labs(\n    title = \"Distribuição por Local\",\n    subtitle = paste(\"Teste Kruskal-Wallis, p =\", format.pval(mode$p.value, digits = 3)),\n    x = \"Local\",\n    y = \"Número de Insetos\"\n  ) +\n  theme_minimal(base_size = 14) +\n  scale_y_continuous(expand = expansion(mult = c(0.05, 0.2))) +\n  scale_fill_viridis_d(option = \"D\", begin = 0.2, end = 0.8)\n```\n\n### Dados do tratamento G\n\n#### Teste post-hoc\n\n```{r}\nif(!require(rstatix)) install.packages(\"rstatix\")\nlibrary(rstatix) \n\n# Teste de Dunn é o post-hoc utilizado para modelos de Kruskal-Wallis\ndunn_g <- dunn_test(num ~ local, data = datag, p.adjust.method = \"bonferroni\")\n```\n\n#### Organizando as letras e ordem dos resultados do tratamento G\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(multcompView)) install.packages(\"multcompView\")\nlibrary(multcompView)\n\n# Criar matriz de comparações para o multcompView\np_g <- setNames(dunn_nt$p.adj, \n                    paste(dunn_g$group1, dunn_g$group2, sep = \"-\"))\n\n# Obter letras de significância\nletter_g <- multcompLetters(p_g)\n\n# Preparar dados para o gráfico\nletras_plot_g <- data.frame(\n  local = names(letter_g$Letters),\n  letra = letter_g$Letters,\n  y_pos = max(datag$num) * 1.1)\n\n\n\n# Definir a ordem desejada das variáveis no eixo x\n\nordem_desejada <- c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\")\n\n# Converter a variável 'local' em fator com a ordem correta\ndatag <- datag %>%\n  mutate(local = factor(local, \n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = ordem_desejada))\n\n# Atualizar também o dataframe letras_plot\nif(exists(\"letras_plot_g\")) {\n  letras_plot_g <- letras_plot_g %>%\n    mutate(local = factor(local, \n                         levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                         labels = ordem_desejada))\n  }\n\n\n# Modificar os níveis do fator nos dados\ndatag <- datag %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n# Atualizar o dataframe letras_plot\nletras_plot_g <- letras_plot_g %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n```\n\n#### Gráfico do tratamento G\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nggplot(datag, aes(x = local, y = num)) +\n  geom_boxplot(aes(fill = local), width = 0.6, show.legend = FALSE) +\n  geom_text(data = letras_plot_g, \n            aes(x = local, y = y_pos, label = letra),\n            size = 6, vjust = 0) +\n  labs(\n    title = \"Distribuição por Local\",\n    subtitle = paste(\"Teste Kruskal-Wallis, p =\", format.pval(mode$p.value, digits = 3)),\n    x = \"Local\",\n    y = \"Número de Insetos\"\n  ) +\n  theme_minimal(base_size = 14) +\n  scale_y_continuous(expand = expansion(mult = c(0.05, 0.2))) +\n  scale_fill_viridis_d(option = \"D\", begin = 0.2, end = 0.8)\n```\n\n### Dados do tratamento C\n\n#### Teste post-hoc\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(rstatix)) install.packages(\"rstatix\")\nlibrary(rstatix) \n\n# Teste de Dunn é o post-hoc utilizado para modelos de Kruskal-Wallis\ndunn_c <- dunn_test(num ~ local, data = datac, p.adjust.method = \"bonferroni\")\n```\n\n#### Organizando as letras e ordem dos resultados do tratamento C\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(multcompView)) install.packages(\"multcompView\")\nlibrary(multcompView)\n\n# Criar matriz de comparações para o multcompView\np_c <- setNames(dunn_c$p.adj, \n                    paste(dunn_c$group1, dunn_c$group2, sep = \"-\"))\n\n# Obter letras de significância\nletter_c <- multcompLetters(p_c)\n\n# Preparar dados para o gráfico\nletras_plot_c <- data.frame(\n  local = names(letter_c$Letters),\n  letra = letter_c$Letters,\n  y_pos = max(datac$num) * 1.1)\n\n\n\n# Definir a ordem desejada das variáveis no eixo x\n\nordem_desejada <- c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\")\n\n# Converter a variável 'local' em fator com a ordem correta\ndatac <- datac %>%\n  mutate(local = factor(local, \n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = ordem_desejada))\n\n# Atualizar também o dataframe letras_plot\nif(exists(\"letras_plot_c\")) {\n  letras_plot_c <- letras_plot_c %>%\n    mutate(local = factor(local, \n                         levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                         labels = ordem_desejada))\n  }\n\n\n# Modificar os níveis do fator nos dados\ndatac <- datac %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n# Atualizar o dataframe letras_plot\nletras_plot_c <- letras_plot_c %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n```\n\n#### Gráfico do tratamento C\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nggplot(datac, aes(x = local, y = num)) +\n  geom_boxplot(aes(fill = local), width = 0.6, show.legend = FALSE) +\n  geom_text(data = letras_plot_c, \n            aes(x = local, y = y_pos, label = letra),\n            size = 6, vjust = 0) +\n  labs(\n    title = \"Distribuição por Local\",\n    subtitle = paste(\"Teste Kruskal-Wallis, p =\", format.pval(mode$p.value, digits = 3)),\n    x = \"Local\",\n    y = \"Número de Insetos\"\n  ) +\n  theme_minimal(base_size = 14) +\n  scale_y_continuous(expand = expansion(mult = c(0.05, 0.2))) +\n  scale_fill_viridis_d(option = \"D\", begin = 0.2, end = 0.8)\n```\n\n### Dados do tratamento T\n\n#### Teste post-hoc\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(rstatix)) install.packages(\"rstatix\")\nlibrary(rstatix) \n\n# Teste de Dunn é o post-hoc utilizado para modelos de Kruskal-Wallis\ndunn_t <- dunn_test(num ~ local, data = datat, p.adjust.method = \"bonferroni\")\n```\n\n#### Organizando as letras e ordem dos resultados do tratamento T\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(multcompView)) install.packages(\"multcompView\")\nlibrary(multcompView)\n\n# Criar matriz de comparações para o multcompView\np_t <- setNames(dunn_t$p.adj, \n                    paste(dunn_t$group1, dunn_t$group2, sep = \"-\"))\n\n# Obter letras de significância\nletter_t <- multcompLetters(p_t)\n\n# Preparar dados para o gráfico\nletras_plot_t <- data.frame(\n  local = names(letter_t$Letters),\n  letra = letter_t$Letters,\n  y_pos = max(datat$num) * 1.1)\n\n\n\n# Definir a ordem desejada das variáveis no eixo x\n\nordem_desejada <- c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\")\n\n# Converter a variável 'local' em fator com a ordem correta\ndatat <- datat %>%\n  mutate(local = factor(local, \n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = ordem_desejada))\n\n# Atualizar também o dataframe letras_plot\nif(exists(\"letras_plot_c\")) {\n  letras_plot_t <- letras_plot_t %>%\n    mutate(local = factor(local, \n                         levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                         labels = ordem_desejada))\n  }\n\n\n# Modificar os níveis do fator nos dados\ndatat <- datat %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n# Atualizar o dataframe letras_plot\nletras_plot_t <- letras_plot_t %>%\n  mutate(local = factor(local,\n                       levels = c(\"neg_1\", \"neg_05\", \"0\", \"0,5\", \"1\"),\n                       labels = c(\"-1\", \"-0.5\", \"0\", \"0.5\", \"1\")))\n\n\n```\n\n#### Gráfico do tratamento T\n\n```{r, echo=FALSE, eval=TRUE}\nif(!require(ggplot2)) install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nggplot(datat, aes(x = local, y = num)) +\n  geom_boxplot(aes(fill = local), width = 0.6, show.legend = FALSE) +\n  geom_text(data = letras_plot_t, \n            aes(x = local, y = y_pos, label = letra),\n            size = 6, vjust = 0) +\n  labs(\n    title = \"Distribuição por Local\",\n    subtitle = paste(\"Teste Kruskal-Wallis, p =\", format.pval(mode$p.value, digits = 3)),\n    x = \"Local\",\n    y = \"Número de Insetos\"\n  ) +\n  theme_minimal(base_size = 14) +\n  scale_y_continuous(expand = expansion(mult = c(0.05, 0.2))) +\n  scale_fill_viridis_d(option = \"D\", begin = 0.2, end = 0.8)\n```\n\n*Com isso, podemos concluir que em todos os tratamentos, os insetos preferem as extremidades do sistema fechado, onde o alimento é presente. Porém, não há diferenças significativas entre as câmaras com alimento contaminado com composto repelente e as câmaras sem a contaminação.*\n\n*Isso indica que o efeito de repelência dos compostos não é significativo.*\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css","https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css"],"toc":true,"toc-depth":2,"output-file":"tratamentos.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":{"light":"minty","dark":"cyborg"},"page-layout":"full","mainfont":"Roboto","title":"tratamentos","editor":"visual"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}